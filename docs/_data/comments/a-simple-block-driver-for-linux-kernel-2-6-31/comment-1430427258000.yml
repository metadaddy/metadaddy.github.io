name: Sarge
date: '2015-04-30 13:54:18'
url: ''
message: "I don't know.. it seems to me that the entire request has been ended (call to __blk_end_request_all), so there should be no more sections left to process, and executing \"break\" instead of \"continue\" is probably the solution; basically ending request processing for this particular full request.  It may not be a good idea to call fetch_request again on an already null or finished request. But, I also see a problem where the top of the loop tests for req != NULL and then immediately in the next if statement, tests for req == NULL. This will never be. So, here, req must be non-NULL. \n\nIn any case, here is my new version. I tried to remove the \"__\" in front of the blk_end* calls, but that caused multiple kernel panics when the module was loaded, so I don't know what that is all about, as the kernel source I have (Ubuntu 3.19.0-15-generic) shows identical code for both functions. No time to track that one down, and this works as it is.\n\nThis new version is tested and it works, not disturbing a healthy system. I also managed to remove the compiler warning for the Version number (which I bumped up).  All licenses are the same: dual BSD/GPL. I didn't change or add to the copyrights because I want to remain anonymous.\n\n(No way to attach files here on this blog as far as I can see, so I'll just post the text. You'll need to reformat as you wish, especially if you want to re-post this in the main article.)\n--- code starts ---\n\n/*\n * A sample, extra-simple block driver. Updated for kernel 2.6.31.\n *\n * (C) 2003 Eklektix, Inc.\n * (C) 2010 Pat Patterson \n * Redistributable under the terms of the GNU GPL.\n */\n\n#include \n#include \n#include \n\n#include  /* printk() */\n#include      /* everything... */\n#include   /* error codes */\n#include   /* size_t */\n#include \n#include \n#include \n#include \n\n#include \n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nstatic char *Version __attribute__((unused)) = \"1.5\";\n\nstatic int major_num = 0;\nmodule_param(major_num, int, 0);\nstatic int logical_block_size = 512;\nmodule_param(logical_block_size, int, 0);\nstatic int nsectors = 1024; /* How big the drive is */\nmodule_param(nsectors, int, 0);\n\n/*\n * We can tweak our hardware sector size, but the kernel talks to us\n * in terms of small sectors, always.\n */\n#define KERNEL_SECTOR_SIZE 512\n\n/*\n * Our request queue.\n */\nstatic struct request_queue *Queue;\n\n/*\n * The internal representation of our device.\n */\nstatic struct sbd_device {\n\tunsigned long size;\n\tspinlock_t lock;\n\tu8 *data;\n\tstruct gendisk *gd;\n} Device;\n\n/*\n * Handle an I/O request.\n */\nstatic void sbd_transfer(struct sbd_device *dev, sector_t sector,\n\t\tunsigned long nsect, char *buffer, int write) {\n\tunsigned long offset = sector * logical_block_size;\n\tunsigned long nbytes = nsect * logical_block_size;\n\n\tif ((offset + nbytes) &gt; dev-&gt;size) {\n\t\tprintk (KERN_NOTICE \"sbd: Beyond-end write (%ld %ld)\\n\", offset, nbytes);\n\t\treturn;\n\t}\n\tif (write)\n\t\tmemcpy(dev-&gt;data + offset, buffer, nbytes);\n\telse\n\t\tmemcpy(buffer, dev-&gt;data + offset, nbytes);\n}\n\nstatic void sbd_request(struct request_queue *q) {\n\tstruct request *req;\n\n\treq = blk_fetch_request(q);\n\twhile (req != NULL) {\n\t\t// blk_fs_request() was removed in 2.6.36 - many thanks to\n\t\t// Christian Paro for the heads up and fix...\n\t\t//if (!blk_fs_request(req)) {\n\t\tif (req-&gt;cmd_type != REQ_TYPE_FS) {\n\t\t\tprintk (KERN_NOTICE \"Skip non-CMD request\\n\");\n\t\t\t__blk_end_request_all(req, -EIO);\n\t\t\treq = blk_fetch_request(q);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsbd_transfer(&amp;Device, blk_rq_pos(req), blk_rq_cur_sectors(req),\n#if LINUX_VERSION_CODE buffer,\n#else\n\t\t\t\tbio_data(req-&gt;bio),\n#endif\n\t\t\t\trq_data_dir(req));\n\t\tif ( ! __blk_end_request_cur(req, 0) ) {\n\t\t\treq = blk_fetch_request(q);\n\t\t}\n\t}\n}\n\n/*\n * The HDIO_GETGEO ioctl is handled in blkdev_ioctl(), which\n * calls this. We need to implement getgeo, since we can't\n * use tools such as fdisk to partition the drive otherwise.\n */\nint sbd_getgeo(struct block_device * block_device, struct hd_geometry * geo) {\n\tlong size;\n\n\t/* We have no real geometry, of course, so make something up. */\n\tsize = Device.size * (logical_block_size / KERNEL_SECTOR_SIZE);\n\tgeo-&gt;cylinders = (size &amp; ~0x3f) &gt;&gt; 6;\n\tgeo-&gt;heads = 4;\n\tgeo-&gt;sectors = 16;\n\tgeo-&gt;start = 0;\n\treturn 0;\n}\n\n/*\n * The device operations structure.\n */\nstatic struct block_device_operations sbd_ops = {\n\t\t.owner  = THIS_MODULE,\n\t\t.getgeo = sbd_getgeo\n};\n\nstatic int __init sbd_init(void) {\n\t/*\n\t * Set up our internal device.\n\t */\n\tDevice.size = nsectors * logical_block_size;\n\tspin_lock_init(&amp;Device.lock);\n\tDevice.data = vmalloc(Device.size);\n\tif (Device.data == NULL)\n\t\treturn -ENOMEM;\n\t/*\n\t * Get a request queue.\n\t */\n\tQueue = blk_init_queue(sbd_request, &amp;Device.lock);\n\tif (Queue == NULL)\n\t\tgoto out;\n\tblk_queue_logical_block_size(Queue, logical_block_size);\n\t/*\n\t * Get registered.\n\t */\n\tmajor_num = register_blkdev(major_num, \"sbd\");\n\tif (major_num major = major_num;\n\tDevice.gd-&gt;first_minor = 0;\n\tDevice.gd-&gt;fops = &amp;sbd_ops;\n\tDevice.gd-&gt;private_data = &amp;Device;\n\tstrcpy(Device.gd-&gt;disk_name, \"sbd0\");\n\tset_capacity(Device.gd, nsectors);\n\tDevice.gd-&gt;queue = Queue;\n\tadd_disk(Device.gd);\n\n\treturn 0;\n\nout_unregister:\n\tunregister_blkdev(major_num, \"sbd\");\nout:\n\tvfree(Device.data);\n\treturn -ENOMEM;\n}\n\nstatic void __exit sbd_exit(void)\n{\n\tdel_gendisk(Device.gd);\n\tput_disk(Device.gd);\n\tunregister_blkdev(major_num, \"sbd\");\n\tblk_cleanup_queue(Queue);\n\tvfree(Device.data);\n}\n\nmodule_init(sbd_init);\nmodule_exit(sbd_exit);\n\n--- code ends ---"
email: d6161c4b308cbf350f83ebae45e18ab9
